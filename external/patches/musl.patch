diff --git a/arch/x86_64/bits/limits.h b/arch/x86_64/bits/limits.h
index 07743b6fd..12420d72c 100644
--- a/arch/x86_64/bits/limits.h
+++ b/arch/x86_64/bits/limits.h
@@ -1 +1 @@
-#define PAGESIZE 4096
+#define PAGESIZE (2 * 1024 * 1024)
diff --git a/include/features.h b/include/features.h
index 85cfb72a0..409edded4 100644
--- a/include/features.h
+++ b/include/features.h
@@ -37,4 +37,14 @@
 
 #define __REDIR(x,y) __typeof__(x) x __asm__(#y)
 
+#if defined(LIBC_THREADED_GLOBALS)
+#if defined(__cplusplus)
+#define LIBC_GLOBAL thread_local
+#else
+#define LIBC_GLOBAL _Thread_local
+#endif
+#else
+#define LIBC_GLOBAL
+#endif
+
 #endif
diff --git a/include/pthread.h b/include/pthread.h
index 89fd9ff7c..54906b9fc 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -28,60 +28,16 @@ extern "C" {
 #include <bits/alltypes.h>
 
 #include <sched.h>
-#include <time.h>
-
-#define PTHREAD_CREATE_JOINABLE 0
-#define PTHREAD_CREATE_DETACHED 1
 
 #define PTHREAD_MUTEX_NORMAL 0
 #define PTHREAD_MUTEX_DEFAULT 0
-#define PTHREAD_MUTEX_RECURSIVE 1
-#define PTHREAD_MUTEX_ERRORCHECK 2
-
-#define PTHREAD_MUTEX_STALLED 0
-#define PTHREAD_MUTEX_ROBUST 1
-
-#define PTHREAD_PRIO_NONE 0
-#define PTHREAD_PRIO_INHERIT 1
-#define PTHREAD_PRIO_PROTECT 2
-
-#define PTHREAD_INHERIT_SCHED 0
-#define PTHREAD_EXPLICIT_SCHED 1
-
-#define PTHREAD_SCOPE_SYSTEM 0
-#define PTHREAD_SCOPE_PROCESS 1
-
-#define PTHREAD_PROCESS_PRIVATE 0
-#define PTHREAD_PROCESS_SHARED 1
-
 
 #define PTHREAD_MUTEX_INITIALIZER {{{0}}}
-#define PTHREAD_RWLOCK_INITIALIZER {{{0}}}
 #define PTHREAD_COND_INITIALIZER {{{0}}}
 #define PTHREAD_ONCE_INIT 0
 
-
-#define PTHREAD_CANCEL_ENABLE 0
-#define PTHREAD_CANCEL_DISABLE 1
-#define PTHREAD_CANCEL_MASKED 2
-
-#define PTHREAD_CANCEL_DEFERRED 0
-#define PTHREAD_CANCEL_ASYNCHRONOUS 1
-
-#define PTHREAD_CANCELED ((void *)-1)
-
-
-#define PTHREAD_BARRIER_SERIAL_THREAD (-1)
-
-
 #define PTHREAD_NULL ((pthread_t)0)
 
-
-int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict);
-int pthread_detach(pthread_t);
-_Noreturn void pthread_exit(void *);
-int pthread_join(pthread_t, void **);
-
 #ifdef __GNUC__
 __attribute__((const))
 #endif
@@ -92,152 +48,25 @@ int pthread_equal(pthread_t, pthread_t);
 #define pthread_equal(x,y) ((x)==(y))
 #endif
 
-int pthread_setcancelstate(int, int *);
-int pthread_setcanceltype(int, int *);
-void pthread_testcancel(void);
-int pthread_cancel(pthread_t);
-
-int pthread_getschedparam(pthread_t, int *__restrict, struct sched_param *__restrict);
-int pthread_setschedparam(pthread_t, int, const struct sched_param *);
-int pthread_setschedprio(pthread_t, int);
-
 int pthread_once(pthread_once_t *, void (*)(void));
 
 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict);
 int pthread_mutex_lock(pthread_mutex_t *);
 int pthread_mutex_unlock(pthread_mutex_t *);
-int pthread_mutex_trylock(pthread_mutex_t *);
-int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict);
 int pthread_mutex_destroy(pthread_mutex_t *);
-int pthread_mutex_consistent(pthread_mutex_t *);
-
-int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict);
-int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict);
 
-int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict);
-int pthread_cond_destroy(pthread_cond_t *);
 int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict);
-int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict);
-int pthread_cond_broadcast(pthread_cond_t *);
 int pthread_cond_signal(pthread_cond_t *);
 
-int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict);
-int pthread_rwlock_destroy(pthread_rwlock_t *);
-int pthread_rwlock_rdlock(pthread_rwlock_t *);
-int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
-int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
-int pthread_rwlock_wrlock(pthread_rwlock_t *);
-int pthread_rwlock_trywrlock(pthread_rwlock_t *);
-int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
-int pthread_rwlock_unlock(pthread_rwlock_t *);
-
-int pthread_spin_init(pthread_spinlock_t *, int);
-int pthread_spin_destroy(pthread_spinlock_t *);
-int pthread_spin_lock(pthread_spinlock_t *);
-int pthread_spin_trylock(pthread_spinlock_t *);
-int pthread_spin_unlock(pthread_spinlock_t *);
-
-int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned);
-int pthread_barrier_destroy(pthread_barrier_t *);
-int pthread_barrier_wait(pthread_barrier_t *);
-
 int pthread_key_create(pthread_key_t *, void (*)(void *));
 int pthread_key_delete(pthread_key_t);
 void *pthread_getspecific(pthread_key_t);
 int pthread_setspecific(pthread_key_t, const void *);
 
-int pthread_attr_init(pthread_attr_t *);
-int pthread_attr_destroy(pthread_attr_t *);
-
-int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict);
-int pthread_attr_setguardsize(pthread_attr_t *, size_t);
-int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict);
-int pthread_attr_setstacksize(pthread_attr_t *, size_t);
-int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
-int pthread_attr_setdetachstate(pthread_attr_t *, int);
-int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict);
-int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
-int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict);
-int pthread_attr_setscope(pthread_attr_t *, int);
-int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict);
-int pthread_attr_setschedpolicy(pthread_attr_t *, int);
-int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict);
-int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict);
-int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict);
-int pthread_attr_setinheritsched(pthread_attr_t *, int);
-
 int pthread_mutexattr_destroy(pthread_mutexattr_t *);
-int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict);
-int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict);
-int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict);
-int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict);
-int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict);
 int pthread_mutexattr_init(pthread_mutexattr_t *);
-int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
-int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
-int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
-int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
 int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
 
-int pthread_condattr_init(pthread_condattr_t *);
-int pthread_condattr_destroy(pthread_condattr_t *);
-int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
-int pthread_condattr_setpshared(pthread_condattr_t *, int);
-int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict);
-int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict);
-
-int pthread_rwlockattr_init(pthread_rwlockattr_t *);
-int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
-int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
-int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict);
-
-int pthread_barrierattr_destroy(pthread_barrierattr_t *);
-int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict);
-int pthread_barrierattr_init(pthread_barrierattr_t *);
-int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
-
-int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
-
-int pthread_getconcurrency(void);
-int pthread_setconcurrency(int);
-
-int pthread_getcpuclockid(pthread_t, clockid_t *);
-
-struct __ptcb {
-	void (*__f)(void *);
-	void *__x;
-	struct __ptcb *__next;
-};
-
-void _pthread_cleanup_push(struct __ptcb *, void (*)(void *), void *);
-void _pthread_cleanup_pop(struct __ptcb *, int);
-
-#define pthread_cleanup_push(f, x) do { struct __ptcb __cb; _pthread_cleanup_push(&__cb, f, x);
-#define pthread_cleanup_pop(r) _pthread_cleanup_pop(&__cb, (r)); } while(0)
-
-#ifdef _GNU_SOURCE
-struct cpu_set_t;
-int pthread_getaffinity_np(pthread_t, size_t, struct cpu_set_t *);
-int pthread_setaffinity_np(pthread_t, size_t, const struct cpu_set_t *);
-int pthread_getattr_np(pthread_t, pthread_attr_t *);
-int pthread_setname_np(pthread_t, const char *);
-int pthread_getname_np(pthread_t, char *, size_t);
-int pthread_getattr_default_np(pthread_attr_t *);
-int pthread_setattr_default_np(const pthread_attr_t *);
-int pthread_tryjoin_np(pthread_t, void **);
-int pthread_timedjoin_np(pthread_t, void **, const struct timespec *);
-#endif
-
-#if _REDIR_TIME64
-__REDIR(pthread_mutex_timedlock, __pthread_mutex_timedlock_time64);
-__REDIR(pthread_cond_timedwait, __pthread_cond_timedwait_time64);
-__REDIR(pthread_rwlock_timedrdlock, __pthread_rwlock_timedrdlock_time64);
-__REDIR(pthread_rwlock_timedwrlock, __pthread_rwlock_timedwrlock_time64);
-#ifdef _GNU_SOURCE
-__REDIR(pthread_timedjoin_np, __pthread_timedjoin_np_time64);
-#endif
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/stdio.h b/include/stdio.h
index d1ed01f03..ca9b5c733 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -59,9 +59,9 @@ typedef union _G_fpos64_t {
 	double __align;
 } fpos_t;
 
-extern FILE *const stdin;
-extern FILE *const stdout;
-extern FILE *const stderr;
+extern LIBC_GLOBAL FILE *const stdin;
+extern LIBC_GLOBAL FILE *const stdout;
+extern LIBC_GLOBAL FILE *const stderr;
 
 #define stdin  (stdin)
 #define stdout (stdout)
diff --git a/include/sys/socket.h b/include/sys/socket.h
index 6dc1e40ad..f7de3b8e3 100644
--- a/include/sys/socket.h
+++ b/include/sys/socket.h
@@ -8,363 +8,14 @@ extern "C" {
 
 #define __NEED_socklen_t
 #define __NEED_sa_family_t
-#define __NEED_size_t
-#define __NEED_ssize_t
-#define __NEED_uid_t
-#define __NEED_pid_t
-#define __NEED_gid_t
-#define __NEED_struct_iovec
 
 #include <bits/alltypes.h>
 
-#include <bits/socket.h>
-
-struct msghdr {
-	void *msg_name;
-	socklen_t msg_namelen;
-	struct iovec *msg_iov;
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
-	int __pad1;
-#endif
-	int msg_iovlen;
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
-	int __pad1;
-#endif
-	void *msg_control;
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
-	int __pad2;
-#endif
-	socklen_t msg_controllen;
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
-	int __pad2;
-#endif
-	int msg_flags;
-};
-
-struct cmsghdr {
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
-	int __pad1;
-#endif
-	socklen_t cmsg_len;
-#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
-	int __pad1;
-#endif
-	int cmsg_level;
-	int cmsg_type;
-};
-
-#ifdef _GNU_SOURCE
-struct ucred {
-	pid_t pid;
-	uid_t uid;
-	gid_t gid;
-};
-
-struct mmsghdr {
-	struct msghdr msg_hdr;
-	unsigned int  msg_len;
-};
-
-struct timespec;
-
-int sendmmsg (int, struct mmsghdr *, unsigned int, unsigned int);
-int recvmmsg (int, struct mmsghdr *, unsigned int, unsigned int, struct timespec *);
-#endif
-
-struct linger {
-	int l_onoff;
-	int l_linger;
-};
-
-#define SHUT_RD 0
-#define SHUT_WR 1
-#define SHUT_RDWR 2
-
-#ifndef SOCK_STREAM
-#define SOCK_STREAM    1
-#define SOCK_DGRAM     2
-#endif
-
-#define SOCK_RAW       3
-#define SOCK_RDM       4
-#define SOCK_SEQPACKET 5
-#define SOCK_DCCP      6
-#define SOCK_PACKET    10
-
-#ifndef SOCK_CLOEXEC
-#define SOCK_CLOEXEC   02000000
-#define SOCK_NONBLOCK  04000
-#endif
-
-#define PF_UNSPEC       0
-#define PF_LOCAL        1
-#define PF_UNIX         PF_LOCAL
-#define PF_FILE         PF_LOCAL
 #define PF_INET         2
-#define PF_AX25         3
-#define PF_IPX          4
-#define PF_APPLETALK    5
-#define PF_NETROM       6
-#define PF_BRIDGE       7
-#define PF_ATMPVC       8
-#define PF_X25          9
 #define PF_INET6        10
-#define PF_ROSE         11
-#define PF_DECnet       12
-#define PF_NETBEUI      13
-#define PF_SECURITY     14
-#define PF_KEY          15
-#define PF_NETLINK      16
-#define PF_ROUTE        PF_NETLINK
-#define PF_PACKET       17
-#define PF_ASH          18
-#define PF_ECONET       19
-#define PF_ATMSVC       20
-#define PF_RDS          21
-#define PF_SNA          22
-#define PF_IRDA         23
-#define PF_PPPOX        24
-#define PF_WANPIPE      25
-#define PF_LLC          26
-#define PF_IB           27
-#define PF_MPLS         28
-#define PF_CAN          29
-#define PF_TIPC         30
-#define PF_BLUETOOTH    31
-#define PF_IUCV         32
-#define PF_RXRPC        33
-#define PF_ISDN         34
-#define PF_PHONET       35
-#define PF_IEEE802154   36
-#define PF_CAIF         37
-#define PF_ALG          38
-#define PF_NFC          39
-#define PF_VSOCK        40
-#define PF_KCM          41
-#define PF_QIPCRTR      42
-#define PF_SMC          43
-#define PF_XDP          44
-#define PF_MAX          45
 
-#define AF_UNSPEC       PF_UNSPEC
-#define AF_LOCAL        PF_LOCAL
-#define AF_UNIX         AF_LOCAL
-#define AF_FILE         AF_LOCAL
 #define AF_INET         PF_INET
-#define AF_AX25         PF_AX25
-#define AF_IPX          PF_IPX
-#define AF_APPLETALK    PF_APPLETALK
-#define AF_NETROM       PF_NETROM
-#define AF_BRIDGE       PF_BRIDGE
-#define AF_ATMPVC       PF_ATMPVC
-#define AF_X25          PF_X25
 #define AF_INET6        PF_INET6
-#define AF_ROSE         PF_ROSE
-#define AF_DECnet       PF_DECnet
-#define AF_NETBEUI      PF_NETBEUI
-#define AF_SECURITY     PF_SECURITY
-#define AF_KEY          PF_KEY
-#define AF_NETLINK      PF_NETLINK
-#define AF_ROUTE        PF_ROUTE
-#define AF_PACKET       PF_PACKET
-#define AF_ASH          PF_ASH
-#define AF_ECONET       PF_ECONET
-#define AF_ATMSVC       PF_ATMSVC
-#define AF_RDS          PF_RDS
-#define AF_SNA          PF_SNA
-#define AF_IRDA         PF_IRDA
-#define AF_PPPOX        PF_PPPOX
-#define AF_WANPIPE      PF_WANPIPE
-#define AF_LLC          PF_LLC
-#define AF_IB           PF_IB
-#define AF_MPLS         PF_MPLS
-#define AF_CAN          PF_CAN
-#define AF_TIPC         PF_TIPC
-#define AF_BLUETOOTH    PF_BLUETOOTH
-#define AF_IUCV         PF_IUCV
-#define AF_RXRPC        PF_RXRPC
-#define AF_ISDN         PF_ISDN
-#define AF_PHONET       PF_PHONET
-#define AF_IEEE802154   PF_IEEE802154
-#define AF_CAIF         PF_CAIF
-#define AF_ALG          PF_ALG
-#define AF_NFC          PF_NFC
-#define AF_VSOCK        PF_VSOCK
-#define AF_KCM          PF_KCM
-#define AF_QIPCRTR      PF_QIPCRTR
-#define AF_SMC          PF_SMC
-#define AF_XDP          PF_XDP
-#define AF_MAX          PF_MAX
-
-#ifndef SO_DEBUG
-#define SO_DEBUG        1
-#define SO_REUSEADDR    2
-#define SO_TYPE         3
-#define SO_ERROR        4
-#define SO_DONTROUTE    5
-#define SO_BROADCAST    6
-#define SO_SNDBUF       7
-#define SO_RCVBUF       8
-#define SO_KEEPALIVE    9
-#define SO_OOBINLINE    10
-#define SO_NO_CHECK     11
-#define SO_PRIORITY     12
-#define SO_LINGER       13
-#define SO_BSDCOMPAT    14
-#define SO_REUSEPORT    15
-#define SO_PASSCRED     16
-#define SO_PEERCRED     17
-#define SO_RCVLOWAT     18
-#define SO_SNDLOWAT     19
-#define SO_ACCEPTCONN   30
-#define SO_PEERSEC      31
-#define SO_SNDBUFFORCE  32
-#define SO_RCVBUFFORCE  33
-#define SO_PROTOCOL     38
-#define SO_DOMAIN       39
-#endif
-
-#ifndef SO_RCVTIMEO
-#if __LONG_MAX == 0x7fffffff
-#define SO_RCVTIMEO     66
-#define SO_SNDTIMEO     67
-#else
-#define SO_RCVTIMEO     20
-#define SO_SNDTIMEO     21
-#endif
-#endif
-
-#ifndef SO_TIMESTAMP
-#if __LONG_MAX == 0x7fffffff
-#define SO_TIMESTAMP    63
-#define SO_TIMESTAMPNS  64
-#define SO_TIMESTAMPING 65
-#else
-#define SO_TIMESTAMP    29
-#define SO_TIMESTAMPNS  35
-#define SO_TIMESTAMPING 37
-#endif
-#endif
-
-#define SO_SECURITY_AUTHENTICATION              22
-#define SO_SECURITY_ENCRYPTION_TRANSPORT        23
-#define SO_SECURITY_ENCRYPTION_NETWORK          24
-
-#define SO_BINDTODEVICE 25
-
-#define SO_ATTACH_FILTER        26
-#define SO_DETACH_FILTER        27
-#define SO_GET_FILTER           SO_ATTACH_FILTER
-
-#define SO_PEERNAME             28
-#define SCM_TIMESTAMP           SO_TIMESTAMP
-#define SO_PASSSEC              34
-#define SCM_TIMESTAMPNS         SO_TIMESTAMPNS
-#define SO_MARK                 36
-#define SCM_TIMESTAMPING        SO_TIMESTAMPING
-#define SO_RXQ_OVFL             40
-#define SO_WIFI_STATUS          41
-#define SCM_WIFI_STATUS         SO_WIFI_STATUS
-#define SO_PEEK_OFF             42
-#define SO_NOFCS                43
-#define SO_LOCK_FILTER          44
-#define SO_SELECT_ERR_QUEUE     45
-#define SO_BUSY_POLL            46
-#define SO_MAX_PACING_RATE      47
-#define SO_BPF_EXTENSIONS       48
-#define SO_INCOMING_CPU         49
-#define SO_ATTACH_BPF           50
-#define SO_DETACH_BPF           SO_DETACH_FILTER
-#define SO_ATTACH_REUSEPORT_CBPF 51
-#define SO_ATTACH_REUSEPORT_EBPF 52
-#define SO_CNX_ADVICE           53
-#define SCM_TIMESTAMPING_OPT_STATS 54
-#define SO_MEMINFO              55
-#define SO_INCOMING_NAPI_ID     56
-#define SO_COOKIE               57
-#define SCM_TIMESTAMPING_PKTINFO 58
-#define SO_PEERGROUPS           59
-#define SO_ZEROCOPY             60
-#define SO_TXTIME               61
-#define SCM_TXTIME              SO_TXTIME
-#define SO_BINDTOIFINDEX        62
-#define SO_DETACH_REUSEPORT_BPF 68
-#define SO_PREFER_BUSY_POLL     69
-#define SO_BUSY_POLL_BUDGET     70
-
-#ifndef SOL_SOCKET
-#define SOL_SOCKET      1
-#endif
-
-#define SOL_IP          0
-#define SOL_IPV6        41
-#define SOL_ICMPV6      58
-
-#define SOL_RAW         255
-#define SOL_DECNET      261
-#define SOL_X25         262
-#define SOL_PACKET      263
-#define SOL_ATM         264
-#define SOL_AAL         265
-#define SOL_IRDA        266
-#define SOL_NETBEUI     267
-#define SOL_LLC         268
-#define SOL_DCCP        269
-#define SOL_NETLINK     270
-#define SOL_TIPC        271
-#define SOL_RXRPC       272
-#define SOL_PPPOL2TP    273
-#define SOL_BLUETOOTH   274
-#define SOL_PNPIPE      275
-#define SOL_RDS         276
-#define SOL_IUCV        277
-#define SOL_CAIF        278
-#define SOL_ALG         279
-#define SOL_NFC         280
-#define SOL_KCM         281
-#define SOL_TLS         282
-#define SOL_XDP         283
-
-#define SOMAXCONN       128
-
-#define MSG_OOB       0x0001
-#define MSG_PEEK      0x0002
-#define MSG_DONTROUTE 0x0004
-#define MSG_CTRUNC    0x0008
-#define MSG_PROXY     0x0010
-#define MSG_TRUNC     0x0020
-#define MSG_DONTWAIT  0x0040
-#define MSG_EOR       0x0080
-#define MSG_WAITALL   0x0100
-#define MSG_FIN       0x0200
-#define MSG_SYN       0x0400
-#define MSG_CONFIRM   0x0800
-#define MSG_RST       0x1000
-#define MSG_ERRQUEUE  0x2000
-#define MSG_NOSIGNAL  0x4000
-#define MSG_MORE      0x8000
-#define MSG_WAITFORONE 0x10000
-#define MSG_BATCH     0x40000
-#define MSG_ZEROCOPY  0x4000000
-#define MSG_FASTOPEN  0x20000000
-#define MSG_CMSG_CLOEXEC 0x40000000
-
-#define __CMSG_LEN(cmsg) (((cmsg)->cmsg_len + sizeof(long) - 1) & ~(long)(sizeof(long) - 1))
-#define __CMSG_NEXT(cmsg) ((unsigned char *)(cmsg) + __CMSG_LEN(cmsg))
-#define __MHDR_END(mhdr) ((unsigned char *)(mhdr)->msg_control + (mhdr)->msg_controllen)
-
-#define CMSG_DATA(cmsg) ((unsigned char *) (((struct cmsghdr *)(cmsg)) + 1))
-#define CMSG_NXTHDR(mhdr, cmsg) ((cmsg)->cmsg_len < sizeof (struct cmsghdr) || \
-	__CMSG_LEN(cmsg) + sizeof(struct cmsghdr) >= __MHDR_END(mhdr) - (unsigned char *)(cmsg) \
-	? 0 : (struct cmsghdr *)__CMSG_NEXT(cmsg))
-#define CMSG_FIRSTHDR(mhdr) ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
-
-#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
-#define CMSG_SPACE(len) (CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))
-#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
-
-#define SCM_RIGHTS      0x01
-#define SCM_CREDENTIALS 0x02
 
 struct sockaddr {
 	sa_family_t sa_family;
@@ -377,38 +28,6 @@ struct sockaddr_storage {
 	unsigned long __ss_align;
 };
 
-int socket (int, int, int);
-int socketpair (int, int, int, int [2]);
-
-int shutdown (int, int);
-
-int bind (int, const struct sockaddr *, socklen_t);
-int connect (int, const struct sockaddr *, socklen_t);
-int listen (int, int);
-int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
-int accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);
-
-int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
-int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
-
-ssize_t send (int, const void *, size_t, int);
-ssize_t recv (int, void *, size_t, int);
-ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
-ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
-ssize_t sendmsg (int, const struct msghdr *, int);
-ssize_t recvmsg (int, struct msghdr *, int);
-
-int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
-int setsockopt (int, int, int, const void *, socklen_t);
-
-int sockatmark (int);
-
-#if _REDIR_TIME64
-#ifdef _GNU_SOURCE
-__REDIR(recvmmsg, __recvmmsg_time64);
-#endif
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/sys/types.h b/include/sys/types.h
index 0c35541da..4be3dfaf9 100644
--- a/include/sys/types.h
+++ b/include/sys/types.h
@@ -6,44 +6,15 @@ extern "C" {
 
 #include <features.h>
 
-#define __NEED_ino_t
-#define __NEED_dev_t
-#define __NEED_uid_t
-#define __NEED_gid_t
-#define __NEED_mode_t
-#define __NEED_nlink_t
 #define __NEED_off_t
-#define __NEED_pid_t
 #define __NEED_size_t
 #define __NEED_ssize_t
 #define __NEED_time_t
 #define __NEED_timer_t
 #define __NEED_clockid_t
 
-#define __NEED_blkcnt_t
-#define __NEED_fsblkcnt_t
-#define __NEED_fsfilcnt_t
-
-#define __NEED_id_t
-#define __NEED_key_t
 #define __NEED_clock_t
 #define __NEED_suseconds_t
-#define __NEED_blksize_t
-
-#define __NEED_pthread_t
-#define __NEED_pthread_attr_t
-#define __NEED_pthread_mutexattr_t
-#define __NEED_pthread_condattr_t
-#define __NEED_pthread_rwlockattr_t
-#define __NEED_pthread_barrierattr_t
-#define __NEED_pthread_mutex_t
-#define __NEED_pthread_cond_t
-#define __NEED_pthread_rwlock_t
-#define __NEED_pthread_barrier_t
-#define __NEED_pthread_spinlock_t
-#define __NEED_pthread_key_t
-#define __NEED_pthread_once_t
-#define __NEED_useconds_t
 
 #if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #define __NEED_int8_t
@@ -71,14 +42,6 @@ typedef unsigned long long u_quad_t;
 #include <sys/select.h>
 #endif
 
-#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
-#define blkcnt64_t blkcnt_t
-#define fsblkcnt64_t fsblkcnt_t
-#define fsfilcnt64_t fsfilcnt_t
-#define ino64_t ino_t
-#define off64_t off_t
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/env/__init_tls.c b/src/env/__init_tls.c
index a93141ed3..fd2c3e15a 100644
--- a/src/env/__init_tls.c
+++ b/src/env/__init_tls.c
@@ -1,153 +1,9 @@
-#define SYSCALL_NO_TLS 1
-#include <elf.h>
-#include <limits.h>
-#include <sys/mman.h>
-#include <string.h>
-#include <stddef.h>
-#include "pthread_impl.h"
 #include "libc.h"
-#include "atomic.h"
-#include "syscall.h"
 
-volatile int __thread_list_lock;
+extern int __gettid();
 
 int __init_tp(void *p)
 {
-	pthread_t td = p;
-	td->self = td;
-	int r = __set_thread_area(TP_ADJ(p));
-	if (r < 0) return -1;
-	if (!r) libc.can_do_threads = 1;
-	td->detach_state = DT_JOINABLE;
-	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
-	td->locale = &libc.global_locale;
-	td->robust_list.head = &td->robust_list.head;
-	td->sysinfo = __sysinfo;
-	td->next = td->prev = td;
+	__pthread.tid = __gettid();
 	return 0;
 }
-
-static struct builtin_tls {
-	char c;
-	struct pthread pt;
-	void *space[16];
-} builtin_tls[1];
-#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)
-
-static struct tls_module main_tls;
-
-void *__copy_tls(unsigned char *mem)
-{
-	pthread_t td;
-	struct tls_module *p;
-	size_t i;
-	uintptr_t *dtv;
-
-#ifdef TLS_ABOVE_TP
-	dtv = (uintptr_t*)(mem + libc.tls_size) - (libc.tls_cnt + 1);
-
-	mem += -((uintptr_t)mem + sizeof(struct pthread)) & (libc.tls_align-1);
-	td = (pthread_t)mem;
-	mem += sizeof(struct pthread);
-
-	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
-		dtv[i] = (uintptr_t)(mem + p->offset) + DTP_OFFSET;
-		memcpy(mem + p->offset, p->image, p->len);
-	}
-#else
-	dtv = (uintptr_t *)mem;
-
-	mem += libc.tls_size - sizeof(struct pthread);
-	mem -= (uintptr_t)mem & (libc.tls_align-1);
-	td = (pthread_t)mem;
-
-	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
-		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
-		memcpy(mem - p->offset, p->image, p->len);
-	}
-#endif
-	dtv[0] = libc.tls_cnt;
-	td->dtv = dtv;
-	return td;
-}
-
-#if ULONG_MAX == 0xffffffff
-typedef Elf32_Phdr Phdr;
-#else
-typedef Elf64_Phdr Phdr;
-#endif
-
-extern weak hidden const size_t _DYNAMIC[];
-
-static void static_init_tls(size_t *aux)
-{
-	unsigned char *p;
-	size_t n;
-	Phdr *phdr, *tls_phdr=0;
-	size_t base = 0;
-	void *mem;
-
-	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
-		phdr = (void *)p;
-		if (phdr->p_type == PT_PHDR)
-			base = aux[AT_PHDR] - phdr->p_vaddr;
-		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
-			base = (size_t)_DYNAMIC - phdr->p_vaddr;
-		if (phdr->p_type == PT_TLS)
-			tls_phdr = phdr;
-		if (phdr->p_type == PT_GNU_STACK &&
-		    phdr->p_memsz > __default_stacksize)
-			__default_stacksize =
-				phdr->p_memsz < DEFAULT_STACK_MAX ?
-				phdr->p_memsz : DEFAULT_STACK_MAX;
-	}
-
-	if (tls_phdr) {
-		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
-		main_tls.len = tls_phdr->p_filesz;
-		main_tls.size = tls_phdr->p_memsz;
-		main_tls.align = tls_phdr->p_align;
-		libc.tls_cnt = 1;
-		libc.tls_head = &main_tls;
-	}
-
-	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
-		& (main_tls.align-1);
-#ifdef TLS_ABOVE_TP
-	main_tls.offset = GAP_ABOVE_TP;
-	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
-		& (main_tls.align-1);
-#else
-	main_tls.offset = main_tls.size;
-#endif
-	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
-
-	libc.tls_align = main_tls.align;
-	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
-#ifdef TLS_ABOVE_TP
-		+ main_tls.offset
-#endif
-		+ main_tls.size + main_tls.align
-		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
-
-	if (libc.tls_size > sizeof builtin_tls) {
-#ifndef SYS_mmap2
-#define SYS_mmap2 SYS_mmap
-#endif
-		mem = (void *)__syscall(
-			SYS_mmap2,
-			0, libc.tls_size, PROT_READ|PROT_WRITE,
-			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
-		/* -4095...-1 cast to void * will crash on dereference anyway,
-		 * so don't bloat the init code checking for error codes and
-		 * explicitly calling a_crash(). */
-	} else {
-		mem = builtin_tls;
-	}
-
-	/* Failure to initialize thread pointer is always fatal. */
-	if (__init_tp(__copy_tls(mem)) < 0)
-		a_crash();
-}
-
-weak_alias(static_init_tls, __init_tls);
diff --git a/src/internal/libc.c b/src/internal/libc.c
index cb0518108..79f3c097d 100644
--- a/src/internal/libc.c
+++ b/src/internal/libc.c
@@ -1,9 +1,6 @@
 #include "libc.h"
+#include "locale_impl.h"
 
-struct __libc __libc;
+struct __libc __libc = {.need_locks = 1};
 
-size_t __hwcap;
-char *__progname=0, *__progname_full=0;
-
-weak_alias(__progname, program_invocation_short_name);
-weak_alias(__progname_full, program_invocation_name);
+thread_local struct __pthread __pthread = {.locale = (locale_t)&__c_locale, .tid = 1};
diff --git a/src/internal/libc.h b/src/internal/libc.h
index 619bba861..faf6caa47 100644
--- a/src/internal/libc.h
+++ b/src/internal/libc.h
@@ -1,58 +1,36 @@
 #ifndef LIBC_H
 #define LIBC_H
 
-#include <stdlib.h>
-#include <stdio.h>
-#include <limits.h>
+#include <locale.h>
+#include <stddef.h>
+#include <threads.h>
 
-struct __locale_map;
-
-struct __locale_struct {
-	const struct __locale_map *cat[6];
-};
-
-struct tls_module {
-	struct tls_module *next;
-	void *image;
-	size_t len, size, align, offset;
-};
-
-struct __libc {
-	char can_do_threads;
-	char threaded;
-	char secure;
-	volatile signed char need_locks;
-	int threads_minus_1;
-	size_t *auxv;
-	struct tls_module *tls_head;
-	size_t tls_size, tls_align, tls_cnt;
-	size_t page_size;
-	struct __locale_struct global_locale;
+struct __libc
+{
+  signed char need_locks;
 };
 
-#ifndef PAGE_SIZE
-#define PAGE_SIZE libc.page_size
-#endif
-
 extern hidden struct __libc __libc;
 #define libc __libc
 
-hidden void __init_libc(char **, char *);
-hidden void __init_tls(size_t *);
-hidden void __init_ssp(void *);
-hidden void __libc_start_init(void);
-hidden void __funcs_on_exit(void);
-hidden void __funcs_on_quick_exit(void);
-hidden void __libc_exit_fini(void);
-hidden void __fork_handler(int);
+struct __pthread
+{
+  locale_t locale;
+  int tid;
+};
+
+extern thread_local hidden struct __pthread __pthread;
 
-extern hidden size_t __hwcap;
-extern hidden size_t __sysinfo;
-extern char *__progname, *__progname_full;
+inline static struct __pthread* __pthread_self()
+{
+  return &__pthread;
+}
 
-extern hidden const char __libc_version[];
+struct __locale_map;
 
-hidden void __synccall(void (*)(void *), void *);
-hidden int __setxid(int, int, int, int);
+struct __locale_struct
+{
+  const struct __locale_map* cat[6];
+};
 
 #endif
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index de2b9d8b4..ca35ef8b6 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -1,205 +1,11 @@
 #ifndef _PTHREAD_IMPL_H
 #define _PTHREAD_IMPL_H
 
-#include <pthread.h>
-#include <signal.h>
-#include <errno.h>
+#include <atomic.h>
+#include <libc.h>
 #include <limits.h>
-#include <sys/mman.h>
-#include "libc.h"
-#include "syscall.h"
-#include "atomic.h"
-#include "futex.h"
 
-#include "pthread_arch.h"
-
-#define pthread __pthread
-
-struct pthread {
-	/* Part 1 -- these fields may be external or
-	 * internal (accessed via asm) ABI. Do not change. */
-	struct pthread *self;
-#ifndef TLS_ABOVE_TP
-	uintptr_t *dtv;
-#endif
-	struct pthread *prev, *next; /* non-ABI */
-	uintptr_t sysinfo;
-#ifndef TLS_ABOVE_TP
-#ifdef CANARY_PAD
-	uintptr_t canary_pad;
-#endif
-	uintptr_t canary;
-#endif
-
-	/* Part 2 -- implementation details, non-ABI. */
-	int tid;
-	int errno_val;
-	volatile int detach_state;
-	volatile int cancel;
-	volatile unsigned char canceldisable, cancelasync;
-	unsigned char tsd_used:1;
-	unsigned char dlerror_flag:1;
-	unsigned char *map_base;
-	size_t map_size;
-	void *stack;
-	size_t stack_size;
-	size_t guard_size;
-	void *result;
-	struct __ptcb *cancelbuf;
-	void **tsd;
-	struct {
-		volatile void *volatile head;
-		long off;
-		volatile void *volatile pending;
-	} robust_list;
-	int h_errno_val;
-	volatile int timer_id;
-	locale_t locale;
-	volatile int killlock[1];
-	char *dlerror_buf;
-	void *stdio_locks;
-
-	/* Part 3 -- the positions of these fields relative to
-	 * the end of the structure is external and internal ABI. */
-#ifdef TLS_ABOVE_TP
-	uintptr_t canary;
-	uintptr_t *dtv;
-#endif
-};
-
-enum {
-	DT_EXITED = 0,
-	DT_EXITING,
-	DT_JOINABLE,
-	DT_DETACHED,
-};
-
-#define __SU (sizeof(size_t)/sizeof(int))
-
-#define _a_stacksize __u.__s[0]
-#define _a_guardsize __u.__s[1]
-#define _a_stackaddr __u.__s[2]
-#define _a_detach __u.__i[3*__SU+0]
-#define _a_sched __u.__i[3*__SU+1]
-#define _a_policy __u.__i[3*__SU+2]
-#define _a_prio __u.__i[3*__SU+3]
-#define _m_type __u.__i[0]
-#define _m_lock __u.__vi[1]
-#define _m_waiters __u.__vi[2]
-#define _m_prev __u.__p[3]
-#define _m_next __u.__p[4]
-#define _m_count __u.__i[5]
-#define _c_shared __u.__p[0]
-#define _c_seq __u.__vi[2]
-#define _c_waiters __u.__vi[3]
-#define _c_clock __u.__i[4]
-#define _c_lock __u.__vi[8]
-#define _c_head __u.__p[1]
-#define _c_tail __u.__p[5]
-#define _rw_lock __u.__vi[0]
-#define _rw_waiters __u.__vi[1]
-#define _rw_shared __u.__i[2]
-#define _b_lock __u.__vi[0]
-#define _b_waiters __u.__vi[1]
-#define _b_limit __u.__i[2]
-#define _b_count __u.__vi[3]
-#define _b_waiters2 __u.__vi[4]
-#define _b_inst __u.__p[3]
-
-#ifndef TP_OFFSET
-#define TP_OFFSET 0
-#endif
-
-#ifndef DTP_OFFSET
-#define DTP_OFFSET 0
-#endif
-
-#ifdef TLS_ABOVE_TP
-#define TP_ADJ(p) ((char *)(p) + sizeof(struct pthread) + TP_OFFSET)
-#define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET))
-#else
-#define TP_ADJ(p) (p)
-#define __pthread_self() ((pthread_t)__get_tp())
-#endif
-
-#ifndef tls_mod_off_t
-#define tls_mod_off_t size_t
-#endif
-
-#define SIGTIMER 32
-#define SIGCANCEL 33
-#define SIGSYNCCALL 34
-
-#define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
-#define SIGPT_SET \
-	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
-	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
-#define SIGTIMER_SET \
-	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
-	 0x80000000 })
-
-void *__tls_get_addr(tls_mod_off_t *);
-hidden int __init_tp(void *);
-hidden void *__copy_tls(unsigned char *);
-hidden void __reset_tls();
-
-hidden void __membarrier_init(void);
-hidden void __dl_thread_cleanup(void);
-hidden void __testcancel();
-hidden void __do_cleanup_push(struct __ptcb *);
-hidden void __do_cleanup_pop(struct __ptcb *);
-hidden void __pthread_tsd_run_dtors();
-
-hidden void __pthread_key_delete_synccall(void (*)(void *), void *);
-hidden int __pthread_key_delete_impl(pthread_key_t);
-
-extern hidden volatile size_t __pthread_tsd_size;
-extern hidden void *__pthread_tsd_main[];
-extern hidden volatile int __eintr_valid_flag;
-
-hidden int __clone(int (*)(void *), void *, int, void *, ...);
-hidden int __set_thread_area(void *);
-hidden int __libc_sigaction(int, const struct sigaction *, struct sigaction *);
-hidden void __unmapself(void *, size_t);
-
-hidden int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
-hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
-hidden void __wait(volatile int *, volatile int *, int, int);
-static inline void __wake(volatile void *addr, int cnt, int priv)
-{
-	if (priv) priv = FUTEX_PRIVATE;
-	if (cnt<0) cnt = INT_MAX;
-	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
-}
-static inline void __futexwait(volatile void *addr, int val, int priv)
-{
-	if (priv) priv = FUTEX_PRIVATE;
-	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
-}
-
-hidden void __acquire_ptc(void);
-hidden void __release_ptc(void);
-hidden void __inhibit_ptc(void);
-
-hidden void __tl_lock(void);
-hidden void __tl_unlock(void);
-hidden void __tl_sync(pthread_t);
-
-extern hidden volatile int __thread_list_lock;
-
-extern hidden volatile int __abort_lock[1];
-
-extern hidden unsigned __default_stacksize;
-extern hidden unsigned __default_guardsize;
-
-#define DEFAULT_STACK_SIZE 131072
-#define DEFAULT_GUARD_SIZE 8192
-
-#define DEFAULT_STACK_MAX (8<<20)
-#define DEFAULT_GUARD_MAX (1<<20)
-
-#define __ATTRP_C11_THREAD ((void*)(uintptr_t)-1)
+extern hidden void __wake(volatile void* addr, int cnt, int priv);
+extern hidden void __futexwait(volatile void* addr, int val, int priv);
 
 #endif
diff --git a/src/locale/locale_map.c b/src/locale/locale_map.c
index da61f7fc0..41408f0a5 100644
--- a/src/locale/locale_map.c
+++ b/src/locale/locale_map.c
@@ -1,16 +1,4 @@
-#include <locale.h>
-#include <string.h>
-#include <sys/mman.h>
-#include <stdlib.h>
 #include "locale_impl.h"
-#include "libc.h"
-#include "lock.h"
-#include "fork_impl.h"
-
-#define malloc __libc_malloc
-#define calloc undef
-#define realloc undef
-#define free undef
 
 const char *__lctrans_impl(const char *msg, const struct __locale_map *lm)
 {
@@ -18,96 +6,3 @@ const char *__lctrans_impl(const char *msg, const struct __locale_map *lm)
 	if (lm) trans = __mo_lookup(lm->map, lm->map_size, msg);
 	return trans ? trans : msg;
 }
-
-static const char envvars[][12] = {
-	"LC_CTYPE",
-	"LC_NUMERIC",
-	"LC_TIME",
-	"LC_COLLATE",
-	"LC_MONETARY",
-	"LC_MESSAGES",
-};
-
-volatile int __locale_lock[1];
-volatile int *const __locale_lockptr = __locale_lock;
-
-const struct __locale_map *__get_locale(int cat, const char *val)
-{
-	static void *volatile loc_head;
-	const struct __locale_map *p;
-	struct __locale_map *new = 0;
-	const char *path = 0, *z;
-	char buf[256];
-	size_t l, n;
-
-	if (!*val) {
-		(val = getenv("LC_ALL")) && *val ||
-		(val = getenv(envvars[cat])) && *val ||
-		(val = getenv("LANG")) && *val ||
-		(val = "C.UTF-8");
-	}
-
-	/* Limit name length and forbid leading dot or any slashes. */
-	for (n=0; n<LOCALE_NAME_MAX && val[n] && val[n]!='/'; n++);
-	if (val[0]=='.' || val[n]) val = "C.UTF-8";
-	int builtin = (val[0]=='C' && !val[1])
-		|| !strcmp(val, "C.UTF-8")
-		|| !strcmp(val, "POSIX");
-
-	if (builtin) {
-		if (cat == LC_CTYPE && val[1]=='.')
-			return (void *)&__c_dot_utf8;
-		return 0;
-	}
-
-	for (p=loc_head; p; p=p->next)
-		if (!strcmp(val, p->name)) return p;
-
-	if (!libc.secure) path = getenv("MUSL_LOCPATH");
-	/* FIXME: add a default path? */
-
-	if (path) for (; *path; path=z+!!*z) {
-		z = __strchrnul(path, ':');
-		l = z - path;
-		if (l >= sizeof buf - n - 2) continue;
-		memcpy(buf, path, l);
-		buf[l] = '/';
-		memcpy(buf+l+1, val, n);
-		buf[l+1+n] = 0;
-		size_t map_size;
-		const void *map = __map_file(buf, &map_size);
-		if (map) {
-			new = malloc(sizeof *new);
-			if (!new) {
-				__munmap((void *)map, map_size);
-				break;
-			}
-			new->map = map;
-			new->map_size = map_size;
-			memcpy(new->name, val, n);
-			new->name[n] = 0;
-			new->next = loc_head;
-			loc_head = new;
-			break;
-		}
-	}
-
-	/* If no locale definition was found, make a locale map
-	 * object anyway to store the name, which is kept for the
-	 * sake of being able to do message translations at the
-	 * application level. */
-	if (!new && (new = malloc(sizeof *new))) {
-		new->map = __c_dot_utf8.map;
-		new->map_size = __c_dot_utf8.map_size;
-		memcpy(new->name, val, n);
-		new->name[n] = 0;
-		new->next = loc_head;
-		loc_head = new;
-	}
-
-	/* For LC_CTYPE, never return a null pointer unless the
-	 * requested name was "C" or "POSIX". */
-	if (!new && cat == LC_CTYPE) new = (void *)&__c_dot_utf8;
-
-	return new;
-}
diff --git a/src/stdio/__stdio_write.c b/src/stdio/__stdio_write.c
index d2d89475b..fe315f700 100644
--- a/src/stdio/__stdio_write.c
+++ b/src/stdio/__stdio_write.c
@@ -1,34 +1,20 @@
 #include "stdio_impl.h"
-#include <sys/uio.h>
+
+size_t __stdio_actual_write(FILE *f, const unsigned char* fbuf, size_t flen, const unsigned char* buf, size_t len);
 
 size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 {
-	struct iovec iovs[2] = {
-		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
-		{ .iov_base = (void *)buf, .iov_len = len }
-	};
-	struct iovec *iov = iovs;
-	size_t rem = iov[0].iov_len + iov[1].iov_len;
-	int iovcnt = 2;
-	ssize_t cnt;
-	for (;;) {
-		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
-		if (cnt == rem) {
-			f->wend = f->buf + f->buf_size;
-			f->wpos = f->wbase = f->buf;
-			return len;
-		}
-		if (cnt < 0) {
-			f->wpos = f->wbase = f->wend = 0;
-			f->flags |= F_ERR;
-			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
-		}
-		rem -= cnt;
-		if (cnt > iov[0].iov_len) {
-			cnt -= iov[0].iov_len;
-			iov++; iovcnt--;
-		}
-		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
-		iov[0].iov_len -= cnt;
+	size_t written = __stdio_actual_write(f, f->wbase, f->wpos - f->wbase, buf, len);
+	if (written == len)
+	{
+		f->wend = f->buf + f->buf_size;
+		f->wpos = f->wbase = f->buf;
+	}
+	else
+	{
+		f->wpos = f->wbase = f->wend = 0;
+		f->flags |= F_ERR;
 	}
+
+	return written;
 }
diff --git a/src/stdio/__stdout_write.c b/src/stdio/__stdout_write.c
index dd1ec60ff..a49601ed1 100644
--- a/src/stdio/__stdout_write.c
+++ b/src/stdio/__stdout_write.c
@@ -1,11 +1,8 @@
+
 #include "stdio_impl.h"
-#include <sys/ioctl.h>
 
 size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
 {
-	struct winsize wsz;
 	f->write = __stdio_write;
-	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
-		f->lbf = -1;
 	return __stdio_write(f, buf, len);
 }
diff --git a/src/stdio/stderr.c b/src/stdio/stderr.c
index f2bc4648d..6f813c2ac 100644
--- a/src/stdio/stderr.c
+++ b/src/stdio/stderr.c
@@ -14,5 +14,5 @@ hidden FILE __stderr_FILE = {
 	.close = __stdio_close,
 	.lock = -1,
 };
-FILE *const stderr = &__stderr_FILE;
+LIBC_GLOBAL FILE *const stderr = &__stderr_FILE;
 FILE *volatile __stderr_used = &__stderr_FILE;
diff --git a/src/stdio/stdout.c b/src/stdio/stdout.c
index 4985a417b..d677dc689 100644
--- a/src/stdio/stdout.c
+++ b/src/stdio/stdout.c
@@ -14,5 +14,5 @@ hidden FILE __stdout_FILE = {
 	.close = __stdio_close,
 	.lock = -1,
 };
-FILE *const stdout = &__stdout_FILE;
+LIBC_GLOBAL FILE *const stdout = &__stdout_FILE;
 FILE *volatile __stdout_used = &__stdout_FILE;
diff --git a/src/time/__tz.c b/src/time/__tz.c
index c34b3eb75..fc653e593 100644
--- a/src/time/__tz.c
+++ b/src/time/__tz.c
@@ -1,360 +1,7 @@
 #include "time_impl.h"
-#include <stdint.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/mman.h>
-#include <ctype.h>
-#include "libc.h"
-#include "lock.h"
-#include "fork_impl.h"
 
-#define malloc __libc_malloc
-#define calloc undef
-#define realloc undef
-#define free undef
-
-long  __timezone = 0;
-int   __daylight = 0;
-char *__tzname[2] = { 0, 0 };
-
-weak_alias(__timezone, timezone);
-weak_alias(__daylight, daylight);
-weak_alias(__tzname, tzname);
-
-static char std_name[TZNAME_MAX+1];
-static char dst_name[TZNAME_MAX+1];
 const char __utc[] = "UTC";
 
-static int dst_off;
-static int r0[5], r1[5];
-
-static const unsigned char *zi, *trans, *index, *types, *abbrevs, *abbrevs_end;
-static size_t map_size;
-
-static char old_tz_buf[32];
-static char *old_tz = old_tz_buf;
-static size_t old_tz_size = sizeof old_tz_buf;
-
-static volatile int lock[1];
-volatile int *const __timezone_lockptr = lock;
-
-static int getint(const char **p)
-{
-	unsigned x;
-	for (x=0; **p-'0'<10U; (*p)++) x = **p-'0' + 10*x;
-	return x;
-}
-
-static int getoff(const char **p)
-{
-	int neg = 0;
-	if (**p == '-') {
-		++*p;
-		neg = 1;
-	} else if (**p == '+') {
-		++*p;
-	}
-	int off = 3600*getint(p);
-	if (**p == ':') {
-		++*p;
-		off += 60*getint(p);
-		if (**p == ':') {
-			++*p;
-			off += getint(p);
-		}
-	}
-	return neg ? -off : off;
-}
-
-static void getrule(const char **p, int rule[5])
-{
-	int r = rule[0] = **p;
-
-	if (r!='M') {
-		if (r=='J') ++*p;
-		else rule[0] = 0;
-		rule[1] = getint(p);
-	} else {
-		++*p; rule[1] = getint(p);
-		++*p; rule[2] = getint(p);
-		++*p; rule[3] = getint(p);
-	}
-
-	if (**p=='/') {
-		++*p;
-		rule[4] = getoff(p);
-	} else {
-		rule[4] = 7200;
-	}
-}
-
-static void getname(char *d, const char **p)
-{
-	int i;
-	if (**p == '<') {
-		++*p;
-		for (i=0; (*p)[i] && (*p)[i]!='>'; i++)
-			if (i<TZNAME_MAX) d[i] = (*p)[i];
-		if ((*p)[i]) ++*p;
-	} else {
-		for (i=0; ((*p)[i]|32)-'a'<26U; i++)
-			if (i<TZNAME_MAX) d[i] = (*p)[i];
-	}
-	*p += i;
-	d[i<TZNAME_MAX?i:TZNAME_MAX] = 0;
-}
-
-#define VEC(...) ((const unsigned char[]){__VA_ARGS__})
-
-static uint32_t zi_read32(const unsigned char *z)
-{
-	return (unsigned)z[0]<<24 | z[1]<<16 | z[2]<<8 | z[3];
-}
-
-static size_t zi_dotprod(const unsigned char *z, const unsigned char *v, size_t n)
-{
-	size_t y;
-	uint32_t x;
-	for (y=0; n; n--, z+=4, v++) {
-		x = zi_read32(z);
-		y += x * *v;
-	}
-	return y;
-}
-
-static void do_tzset()
-{
-	char buf[NAME_MAX+25], *pathname=buf+24;
-	const char *try, *s, *p;
-	const unsigned char *map = 0;
-	size_t i;
-	static const char search[] =
-		"/usr/share/zoneinfo/\0/share/zoneinfo/\0/etc/zoneinfo/\0";
-
-	s = getenv("TZ");
-	if (!s) s = "/etc/localtime";
-	if (!*s) s = __utc;
-
-	if (old_tz && !strcmp(s, old_tz)) return;
-
-	for (i=0; i<5; i++) r0[i] = r1[i] = 0;
-
-	if (zi) __munmap((void *)zi, map_size);
-
-	/* Cache the old value of TZ to check if it has changed. Avoid
-	 * free so as not to pull it into static programs. Growth
-	 * strategy makes it so free would have minimal benefit anyway. */
-	i = strlen(s);
-	if (i > PATH_MAX+1) s = __utc, i = 3;
-	if (i >= old_tz_size) {
-		old_tz_size *= 2;
-		if (i >= old_tz_size) old_tz_size = i+1;
-		if (old_tz_size > PATH_MAX+2) old_tz_size = PATH_MAX+2;
-		old_tz = malloc(old_tz_size);
-	}
-	if (old_tz) memcpy(old_tz, s, i+1);
-
-	int posix_form = 0;
-	if (*s != ':') {
-		p = s;
-		char dummy_name[TZNAME_MAX+1];
-		getname(dummy_name, &p);
-		if (p!=s && (*p == '+' || *p == '-' || isdigit(*p)
-		             || !strcmp(dummy_name, "UTC")
-		             || !strcmp(dummy_name, "GMT")))
-			posix_form = 1;
-	}	
-
-	/* Non-suid can use an absolute tzfile pathname or a relative
-	 * pathame beginning with "."; in secure mode, only the
-	 * standard path will be searched. */
-	if (!posix_form) {
-		if (*s == ':') s++;
-		if (*s == '/' || *s == '.') {
-			if (!libc.secure || !strcmp(s, "/etc/localtime"))
-				map = __map_file(s, &map_size);
-		} else {
-			size_t l = strlen(s);
-			if (l <= NAME_MAX && !strchr(s, '.')) {
-				memcpy(pathname, s, l+1);
-				pathname[l] = 0;
-				for (try=search; !map && *try; try+=l+1) {
-					l = strlen(try);
-					memcpy(pathname-l, try, l);
-					map = __map_file(pathname-l, &map_size);
-				}
-			}
-		}
-		if (!map) s = __utc;
-	}
-	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
-		__munmap((void *)map, map_size);
-		map = 0;
-		s = __utc;
-	}
-
-	zi = map;
-	if (map) {
-		int scale = 2;
-		if (map[4]!='1') {
-			size_t skip = zi_dotprod(zi+20, VEC(1,1,8,5,6,1), 6);
-			trans = zi+skip+44+44;
-			scale++;
-		} else {
-			trans = zi+44;
-		}
-		index = trans + (zi_read32(trans-12) << scale);
-		types = index + zi_read32(trans-12);
-		abbrevs = types + 6*zi_read32(trans-8);
-		abbrevs_end = abbrevs + zi_read32(trans-4);
-		if (zi[map_size-1] == '\n') {
-			for (s = (const char *)zi+map_size-2; *s!='\n'; s--);
-			s++;
-		} else {
-			const unsigned char *p;
-			__tzname[0] = __tzname[1] = 0;
-			__daylight = __timezone = dst_off = 0;
-			for (p=types; p<abbrevs; p+=6) {
-				if (!p[4] && !__tzname[0]) {
-					__tzname[0] = (char *)abbrevs + p[5];
-					__timezone = -zi_read32(p);
-				}
-				if (p[4] && !__tzname[1]) {
-					__tzname[1] = (char *)abbrevs + p[5];
-					dst_off = -zi_read32(p);
-					__daylight = 1;
-				}
-			}
-			if (!__tzname[0]) __tzname[0] = __tzname[1];
-			if (!__tzname[0]) __tzname[0] = (char *)__utc;
-			if (!__daylight) {
-				__tzname[1] = __tzname[0];
-				dst_off = __timezone;
-			}
-			return;
-		}
-	}
-
-	if (!s) s = __utc;
-	getname(std_name, &s);
-	__tzname[0] = std_name;
-	__timezone = getoff(&s);
-	getname(dst_name, &s);
-	__tzname[1] = dst_name;
-	if (dst_name[0]) {
-		__daylight = 1;
-		if (*s == '+' || *s=='-' || *s-'0'<10U)
-			dst_off = getoff(&s);
-		else
-			dst_off = __timezone - 3600;
-	} else {
-		__daylight = 0;
-		dst_off = __timezone;
-	}
-
-	if (*s == ',') s++, getrule(&s, r0);
-	if (*s == ',') s++, getrule(&s, r1);
-}
-
-/* Search zoneinfo rules to find the one that applies to the given time,
- * and determine alternate opposite-DST-status rule that may be needed. */
-
-static size_t scan_trans(long long t, int local, size_t *alt)
-{
-	int scale = 3 - (trans == zi+44);
-	uint64_t x;
-	int off = 0;
-
-	size_t a = 0, n = (index-trans)>>scale, m;
-
-	if (!n) {
-		if (alt) *alt = 0;
-		return 0;
-	}
-
-	/* Binary search for 'most-recent rule before t'. */
-	while (n > 1) {
-		m = a + n/2;
-		x = zi_read32(trans + (m<<scale));
-		if (scale == 3) x = x<<32 | zi_read32(trans + (m<<scale) + 4);
-		else x = (int32_t)x;
-		if (local) off = (int32_t)zi_read32(types + 6 * index[m-1]);
-		if (t - off < (int64_t)x) {
-			n /= 2;
-		} else {
-			a = m;
-			n -= n/2;
-		}
-	}
-
-	/* First and last entry are special. First means to use lowest-index
-	 * non-DST type. Last means to apply POSIX-style rule if available. */
-	n = (index-trans)>>scale;
-	if (a == n-1) return -1;
-	if (a == 0) {
-		x = zi_read32(trans);
-		if (scale == 3) x = x<<32 | zi_read32(trans + 4);
-		else x = (int32_t)x;
-		/* Find the lowest non-DST type, or 0 if none. */
-		size_t j = 0;
-		for (size_t i=abbrevs-types; i; i-=6) {
-			if (!types[i-6+4]) j = i-6;
-		}
-		if (local) off = (int32_t)zi_read32(types + j);
-		/* If t is before first transition, use the above-found type
-		 * and the index-zero (after transition) type as the alt. */
-		if (t - off < (int64_t)x) {
-			if (alt) *alt = index[0];
-			return j/6;
-		}
-	}
-
-	/* Try to find a neighboring opposite-DST-status rule. */
-	if (alt) {
-		if (a && types[6*index[a-1]+4] != types[6*index[a]+4])
-			*alt = index[a-1];
-		else if (a+1<n && types[6*index[a+1]+4] != types[6*index[a]+4])
-			*alt = index[a+1];
-		else
-			*alt = index[a];
-	}
-
-	return index[a];
-}
-
-static int days_in_month(int m, int is_leap)
-{
-	if (m==2) return 28+is_leap;
-	else return 30+((0xad5>>(m-1))&1);
-}
-
-/* Convert a POSIX DST rule plus year to seconds since epoch. */
-
-static long long rule_to_secs(const int *rule, int year)
-{
-	int is_leap;
-	long long t = __year_to_secs(year, &is_leap);
-	int x, m, n, d;
-	if (rule[0]!='M') {
-		x = rule[1];
-		if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
-		t += 86400 * x;
-	} else {
-		m = rule[1];
-		n = rule[2];
-		d = rule[3];
-		t += __month_to_secs(m-1, is_leap);
-		int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
-		int days = d - wday;
-		if (days < 0) days += 7;
-		if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
-		t += 86400 * (days + 7*(n-1));
-	}
-	t += rule[4];
-	return t;
-}
-
 /* Determine the time zone in effect for a given time in seconds since the
  * epoch. It can be given in local or universal time. The results will
  * indicate whether DST is in effect at the queried time, and will give both
@@ -364,76 +11,19 @@ static long long rule_to_secs(const int *rule, int year)
 
 void __secs_to_zone(long long t, int local, int *isdst, long *offset, long *oppoff, const char **zonename)
 {
-	LOCK(lock);
-
-	do_tzset();
-
-	if (zi) {
-		size_t alt, i = scan_trans(t, local, &alt);
-		if (i != -1) {
-			*isdst = types[6*i+4];
-			*offset = (int32_t)zi_read32(types+6*i);
-			*zonename = (const char *)abbrevs + types[6*i+5];
-			if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
-			UNLOCK(lock);
-			return;
-		}
-	}
-
-	if (!__daylight) goto std;
-
-	/* FIXME: may be broken if DST changes right at year boundary?
-	 * Also, this could be more efficient.*/
-	long long y = t / 31556952 + 70;
-	while (__year_to_secs(y, 0) > t) y--;
-	while (__year_to_secs(y+1, 0) < t) y++;
-
-	long long t0 = rule_to_secs(r0, y);
-	long long t1 = rule_to_secs(r1, y);
-
-	if (!local) {
-		t0 += __timezone;
-		t1 += dst_off;
-	}
-	if (t0 < t1) {
-		if (t >= t0 && t < t1) goto dst;
-		goto std;
-	} else {
-		if (t >= t1 && t < t0) goto std;
-		goto dst;
-	}
-std:
 	*isdst = 0;
-	*offset = -__timezone;
-	if (oppoff) *oppoff = -dst_off;
-	*zonename = __tzname[0];
-	UNLOCK(lock);
-	return;
-dst:
-	*isdst = 1;
-	*offset = -dst_off;
-	if (oppoff) *oppoff = -__timezone;
-	*zonename = __tzname[1];
-	UNLOCK(lock);
-}
-
-static void __tzset()
-{
-	LOCK(lock);
-	do_tzset();
-	UNLOCK(lock);
+	*offset = 0;
+	if (oppoff)
+	{
+		*oppoff = 0;
+	}
+	*zonename = __utc;
 }
 
-weak_alias(__tzset, tzset);
-
 const char *__tm_to_tzname(const struct tm *tm)
 {
 	const void *p = tm->__tm_zone;
-	LOCK(lock);
-	do_tzset();
-	if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
-	    (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs))
+	if (p != __utc)
 		p = "";
-	UNLOCK(lock);
 	return p;
 }
